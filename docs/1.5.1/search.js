window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "fizgrid", "modulename": "fizgrid", "kind": "module", "doc": "<h1 id=\"fizgrid\">Fizgrid</h1>\n\n<p><a href=\"https://badge.fury.io/py/fizgrid\"><img src=\"https://badge.fury.io/py/fizgrid.svg\" alt=\"PyPI version\" /></a>\n<a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"License: MIT\" /></a></p>\n\n<p>Simulate entities that take up space over time in grid based environments. </p>\n\n<h2 id=\"overview\">Overview</h2>\n\n<p>This package introduces a new approach to simulating physical movement within a grid. Rather than following the traditional method of discretizing time and iterating over spatial configurations, this simulation inverts the model: space is discretized, and time is continuous.</p>\n\n<p>Events are scheduled into a priority queue, ordered by their occurrence time. The simulation processes events in chronological order, updating only the relevant entities and grid cells affected by each event. This design allows for highly efficient simulation of large numbers of entities over long periods of simulated time.</p>\n\n<h3 id=\"entity-movement-and-scheduling\">Entity Movement and Scheduling</h3>\n\n<p>Entity movements are planned in advance but only realized when an associated event is triggered. When a route is assigned to an entity, each grid cell along its path is reserved for the time the entity is expected to occupy it. During this reservation process, the system checks for potential conflicts. For example, whether another entity is scheduled to occupy the same cell at the same time.</p>\n\n<p>If a conflict is detected, a collision event is added to the queue for both entities. Only the first potential collision between any pair of entities is added to avoid redundancy. Additionally, an end-of-route event is queued for the entity to signal the completion of its movement.</p>\n\n<h3 id=\"event-handling\">Event Handling</h3>\n\n<p>When an end-of-route event is processed:</p>\n\n<ul>\n<li>The entity\u2019s position is updated to where it would be at that time.</li>\n<li>All pending events related to its previous route are removed from the queue.</li>\n<li>A placeholder (blank) route is assigned to the entity to occupy its current position until a new route is defined.\n<ul>\n<li>This may trigger new collisions, which will be resolved in their own time.</li>\n</ul></li>\n</ul>\n\n<p>When a collision event is processed:</p>\n\n<ul>\n<li>The entity is moved to its calculated position at the collision time.</li>\n<li>All future events tied to its current route are removed.</li>\n<li>Collision events for other entities that would have involved this entity are also removed.\n<ul>\n<li>The counterpart entity in the current collision still processes its corresponding event.</li>\n</ul></li>\n<li>A blank route is assigned to the entity to mark its occupancy of the current cell until reassigned.\n<ul>\n<li>This may trigger new collisions will be resolved in their own time.</li>\n</ul></li>\n</ul>\n\n<h2 id=\"setup\">Setup</h2>\n\n<p>Make sure you have Python 3.10.x (or higher) installed on your system. You can download it <a href=\"https://www.python.org/downloads/\">here</a>.</p>\n\n<h3 id=\"installation\">Installation</h3>\n\n<pre><code>pip install fizgrid\n</code></pre>\n\n<h2 id=\"basic-usage\">Basic Usage</h2>\n\n<h3 id=\"technical-docs\">Technical Docs</h3>\n\n<p>The technical documentation is available at <a href=\"https://connor-makowski.github.io/fizgrid/index.html\">https://connor-makowski.github.io/fizgrid/index.html</a>.</p>\n\n<h3 id=\"example\">Example</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.grid</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Grid</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.entities</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Entity</span><span class=\"p\">,</span> <span class=\"n\">StaticEntity</span><span class=\"p\">,</span> <span class=\"n\">GhostEntity</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.utils</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Shape</span>\n\n<span class=\"c1\"># Create a grid with exterior walls</span>\n<span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;living_room&quot;</span><span class=\"p\">,</span>\n    <span class=\"n\">x_size</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">y_size</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">add_exterior_walls</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"n\">cell_density</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Add some static entities</span>\n<span class=\"n\">sofa</span> <span class=\"o\">=</span> <span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_entity</span><span class=\"p\">(</span>\n    <span class=\"n\">StaticEntity</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;sofa&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">Shape</span><span class=\"o\">.</span><span class=\"n\">rectangle</span><span class=\"p\">(</span><span class=\"n\">x_len</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">y_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n        <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n        <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mf\">5.5</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Add a dynamic entity</span>\n<span class=\"n\">robot</span> <span class=\"o\">=</span> <span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_entity</span><span class=\"p\">(</span>\n    <span class=\"n\">Entity</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;robot&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">Shape</span><span class=\"o\">.</span><span class=\"n\">rectangle</span><span class=\"p\">(</span><span class=\"n\">x_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">y_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n        <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n        <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Add a dynamic entity that can pass through other entities</span>\n<span class=\"n\">ghost</span> <span class=\"o\">=</span> <span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_entity</span><span class=\"p\">(</span>\n    <span class=\"n\">GhostEntity</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;ghost&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">Shape</span><span class=\"o\">.</span><span class=\"n\">rectangle</span><span class=\"p\">(</span><span class=\"n\">x_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">y_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n        <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n        <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Attempt to move the robot through the sofa</span>\n<span class=\"c1\"># Starting at time=0, the robot will try to move to (5,8) over 12 seconds</span>\n<span class=\"c1\"># This will bump into the sofa and stop</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">add_route</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">waypoints</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">)])</span>\n\n\n<span class=\"c1\"># Attempt to move the ghost through the sofa</span>\n<span class=\"c1\"># Starting at time=0, the ghost will try to move to (5,8) over 12 seconds</span>\n<span class=\"c1\"># This will not bump into the sofa and complete its route</span>\n<span class=\"n\">ghost</span><span class=\"o\">.</span><span class=\"n\">add_route</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">waypoints</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">)])</span>\n\n<span class=\"c1\"># Simulate the grid</span>\n<span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">simulate</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Show the history of the robot</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">history</span><span class=\"p\">)</span>\n<span class=\"c1\"># [{&#39;x&#39;: 5, &#39;y&#39;: 2, &#39;t&#39;: 0, &#39;c&#39;: False}, {&#39;x&#39;: 5.0, &#39;y&#39;: 4.5, &#39;t&#39;: 5.0, &#39;c&#39;: True}]</span>\n<span class=\"c1\"># This means that the robot started at (5,2) at time=0 and moved to (5,4.5) at time=5 where it collided with the sofa</span>\n<span class=\"c1\"># Since there is no additional logic to handle the collision, the robot just stopped moving at time 5 and waited for the end of the simulation</span>\n\n\n<span class=\"c1\"># Show the history of the ghost</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ghost</span><span class=\"o\">.</span><span class=\"n\">history</span><span class=\"p\">)</span>\n<span class=\"c1\"># [{&#39;x&#39;: 5, &#39;y&#39;: 2, &#39;t&#39;: 0, &#39;c&#39;: False}, {&#39;x&#39;: 5, &#39;y&#39;: 8, &#39;t&#39;: 12, &#39;c&#39;: False}]</span>\n<span class=\"c1\"># This means that the ghost started at (5,2) at time=0 and moved to (5,8) at time=12 without any collisions</span>\n</code></pre>\n</div>\n\n<h2 id=\"advanced-usage\">Advanced Usage</h2>\n\n<h3 id=\"create-a-custom-sniffer-entity\">Create a custom sniffer entity</h3>\n\n<p>Create a Truffle Pig that sniffs out truffles on a grid. </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.grid</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Grid</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.entities</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Entity</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">fizgrid.utils</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Shape</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">random</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"nn\">math</span>\n\n\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Pig</span><span class=\"p\">(</span><span class=\"n\">Entity</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Override the init method of the Entity class to extend the functionality and add custom attributes.</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tolerance</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">speed</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">get_dist_from_goal</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># A function to calculate the distance from the entity to the goal.</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span>\n            <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x_coord</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n            <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">y_coord</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n        <span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mf\">0.5</span>\n\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">detect_truffle</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x_coord</span><span class=\"p\">,</span> <span class=\"n\">y_coord</span><span class=\"p\">,</span> <span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Set the goal for the entity to reach and start the routing process.</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"o\">=</span> <span class=\"n\">x_coord</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"o\">=</span> <span class=\"n\">y_coord</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tolerance</span> <span class=\"o\">=</span> <span class=\"n\">tolerance</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_next_route</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">add_next_route</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Determine the next route for the entity to take.</span>\n\n        <span class=\"c1\"># This route is randomly calculated based on the angle and distance to the goal.</span>\n        <span class=\"c1\">#     - If the entity is within the tolerance of the goal, it will stop.</span>\n        <span class=\"c1\">#     - If the entity is not within the tolerance</span>\n        <span class=\"c1\">#         - It will calculate the target angle towards the goal.</span>\n        <span class=\"c1\">#         - It will calculate the target distance to the goal.</span>\n        <span class=\"c1\">#         - A random angle is generated by using a normal distribution centered on the goal angle.</span>\n        <span class=\"c1\">#         - A random distance is generated between 0 and the minimum of the distance to the goal and 5.</span>\n        <span class=\"n\">distance_from_goal</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_dist_from_goal</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">distance_from_goal</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tolerance</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span>\n        <span class=\"n\">goal_angle_rad</span> <span class=\"o\">=</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">atan2</span><span class=\"p\">(</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">y_coord</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"o\">-</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x_coord</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">random_angle</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normalvariate</span><span class=\"p\">(</span><span class=\"n\">goal_angle_rad</span><span class=\"p\">,</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">uniform</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">distance_from_goal</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n        <span class=\"n\">x_shift</span> <span class=\"o\">=</span> <span class=\"n\">distance</span> <span class=\"o\">*</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">random_angle</span><span class=\"p\">)</span>\n        <span class=\"n\">y_shift</span> <span class=\"o\">=</span> <span class=\"n\">distance</span> <span class=\"o\">*</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">random_angle</span><span class=\"p\">)</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_route</span><span class=\"p\">(</span>\n            <span class=\"n\">waypoints</span><span class=\"o\">=</span><span class=\"p\">[</span>\n                <span class=\"p\">(</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x_coord</span> <span class=\"o\">+</span> <span class=\"n\">x_shift</span><span class=\"p\">,</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">y_coord</span> <span class=\"o\">+</span> <span class=\"n\">y_shift</span><span class=\"p\">,</span>\n                    <span class=\"n\">distance</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">speed</span><span class=\"p\">,</span>\n                <span class=\"p\">),</span>\n            <span class=\"p\">]</span>\n        <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">on_realize</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># This method is a blank method that should be overridden by the user.</span>\n        <span class=\"c1\"># It is called when an event for the entity is realized.</span>\n\n        <span class=\"c1\"># In this case, it is used to implment the goal checking logic and continuously add routes until the goal is reached.</span>\n\n        <span class=\"c1\"># The method checks if the entity has a goal set and if it is within the tolerance of the goal.</span>\n        <span class=\"c1\"># If the entity is not within the tolerance, it will add the next route.</span>\n        <span class=\"c1\"># If the entity is within the tolerance, it will set the goal to None.</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">get_dist_from_goal</span><span class=\"p\">()</span> <span class=\"o\">&gt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tolerance</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_next_route</span><span class=\"p\">()</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_x</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">goal_y</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n\n<span class=\"n\">forest</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;forest&quot;</span><span class=\"p\">,</span>\n    <span class=\"n\">x_size</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n    <span class=\"n\">y_size</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n    <span class=\"n\">cell_density</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"n\">add_exterior_walls</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Add some pigs to the forest</span>\n<span class=\"n\">truffle_pig_1</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"n\">add_entity</span><span class=\"p\">(</span>\n    <span class=\"n\">Pig</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;Truffle_Pig_1&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">Shape</span><span class=\"o\">.</span><span class=\"n\">rectangle</span><span class=\"p\">(</span><span class=\"n\">x_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">y_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">round_to</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">),</span>\n        <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">45</span><span class=\"p\">,</span>\n        <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span>\n        <span class=\"n\">auto_rotate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n<span class=\"n\">truffle_pig_2</span> <span class=\"o\">=</span> <span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"n\">add_entity</span><span class=\"p\">(</span>\n    <span class=\"n\">Pig</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s2\">&quot;Truffle_Pig_2&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">Shape</span><span class=\"o\">.</span><span class=\"n\">rectangle</span><span class=\"p\">(</span><span class=\"n\">x_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">y_len</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">round_to</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">),</span>\n        <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span>\n        <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">45</span><span class=\"p\">,</span>\n        <span class=\"n\">auto_rotate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">truffle_pig_1</span><span class=\"o\">.</span><span class=\"n\">detect_truffle</span><span class=\"p\">(</span>\n    <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">55</span><span class=\"p\">,</span>\n    <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">truffle_pig_2</span><span class=\"o\">.</span><span class=\"n\">detect_truffle</span><span class=\"p\">(</span>\n    <span class=\"n\">x_coord</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span>\n    <span class=\"n\">y_coord</span><span class=\"o\">=</span><span class=\"mi\">55</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Run the sim</span>\n<span class=\"n\">forest</span><span class=\"o\">.</span><span class=\"n\">simulate</span><span class=\"p\">()</span>\n\n<span class=\"nb\">print</span><span class=\"p\">({</span>\n    <span class=\"s1\">&#39;Name&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_1</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;x_coord&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_1</span><span class=\"o\">.</span><span class=\"n\">x_coord</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;y_coord&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_1</span><span class=\"o\">.</span><span class=\"n\">y_coord</span><span class=\"p\">,</span>\n<span class=\"p\">})</span>\n<span class=\"nb\">print</span><span class=\"p\">({</span>\n    <span class=\"s1\">&#39;Name&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_2</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;x_coord&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_2</span><span class=\"o\">.</span><span class=\"n\">x_coord</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;y_coord&#39;</span><span class=\"p\">:</span> <span class=\"n\">truffle_pig_2</span><span class=\"o\">.</span><span class=\"n\">y_coord</span><span class=\"p\">,</span>\n<span class=\"p\">})</span>\n\n<span class=\"c1\"># Example Output</span>\n<span class=\"c1\"># {&#39;Name&#39;: &#39;Truffle_Pig_1&#39;, &#39;x_coord&#39;: 54.6408, &#39;y_coord&#39;: 50.3864}</span>\n<span class=\"c1\"># {&#39;Name&#39;: &#39;Truffle_Pig_2&#39;, &#39;x_coord&#39;: 50.1886, &#39;y_coord&#39;: 55.9795}</span>\n</code></pre>\n</div>\n\n<h2 id=\"helpers-and-utils\">Helpers and Utils</h2>\n\n<p>Fizgrid provides a number of utils and helper functions to streamline your workflows.</p>\n\n<p>You should take special note of the following:</p>\n\n<ul>\n<li><code>fizgrid.utils.Shape</code>: A class to help define the shape of an entity. (See: <a href=\"https://connor-makowski.github.io/fizgrid/fizgrid/utils.html#Shape\">Shape</a>)</li>\n<li><code>fizgrid.helpers.waypoint_timing</code>: A function to help calculate the timing of waypoints. (See: <a href=\"https://connor-makowski.github.io/fizgrid/fizgrid/helpers/waypoint_timing.html\">waypoint_timing</a>)</li>\n</ul>\n\n<h1 id=\"development\">Development</h1>\n\n<h2 id=\"running-tests-prettifying-code-and-updating-docs\">Running Tests, Prettifying Code, and Updating Docs</h2>\n\n<p>Make sure Docker is installed and running on a Unix system (Linux, MacOS, WSL2).</p>\n\n<ul>\n<li>Create a docker container and drop into a shell\n<ul>\n<li><code>./run.sh</code></li>\n</ul></li>\n<li>Run all tests (see ./utils/test.sh)\n<ul>\n<li><code>./run.sh test</code></li>\n</ul></li>\n<li>Prettify the code (see ./utils/prettify.sh)\n<ul>\n<li><code>./run.sh prettify</code></li>\n</ul></li>\n<li><p>Update the docs (see ./utils/docs.sh)</p>\n\n<ul>\n<li><code>./run.sh docs</code></li>\n</ul></li>\n<li><p>Note: You can and should modify the <code>Dockerfile</code> to test different python versions.</p></li>\n</ul>\n"}, {"fullname": "fizgrid.entities", "modulename": "fizgrid.entities", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.entities.Entity", "modulename": "fizgrid.entities", "qualname": "Entity", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "fizgrid.entities.Entity.__init__", "modulename": "fizgrid.entities", "qualname": "Entity.__init__", "kind": "function", "doc": "<p>Initializes an entity with a given shape and location in the grid.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>id (int): The ID of the entity.</li>\n<li>name (str): The name of the entity.</li>\n<li>shape (list[list[int|float]]): The shape of the entity as a list of points centered around the shape origin.\n<ul>\n<li>The shape origin referenced here should be the center of the shape as the shape origin is used to determine how the shape is located on the grid.</li>\n<li>The shape is a list of points, where each point is a list of two coordinates [x, y] relative to the shape origin.</li>\n</ul></li>\n<li>x_coord (int|float): The starting x-coordinate of the entity in the grid.</li>\n<li>y_coord (int|float): The starting y-coordinate of the entity in the grid.</li>\n<li>auto_rotate (bool): Whether to automatically rotate the shape based on the direction of movement.\n<ul>\n<li>Note: The default assumption is that the shape is facing right (0 radians).</li>\n</ul></li>\n<li>location_precision (int): The precision of the location coordinates. This is used to round the coordinates to a specific number of decimal places.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">x_coord</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y_coord</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">auto_rotate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">location_precision</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span>)</span>"}, {"fullname": "fizgrid.entities.Entity.id", "modulename": "fizgrid.entities", "qualname": "Entity.id", "kind": "variable", "doc": "<p>The ID of the entity.</p>\n"}, {"fullname": "fizgrid.entities.Entity.name", "modulename": "fizgrid.entities", "qualname": "Entity.name", "kind": "variable", "doc": "<p>The name of the entity.</p>\n"}, {"fullname": "fizgrid.entities.Entity.shape", "modulename": "fizgrid.entities", "qualname": "Entity.shape", "kind": "variable", "doc": "<p>The shape of the entity as a list of points centered around the shape the current (x, y) coordinates.</p>\n"}, {"fullname": "fizgrid.entities.Entity.x_coord", "modulename": "fizgrid.entities", "qualname": "Entity.x_coord", "kind": "variable", "doc": "<p>The x-coordinate of the entity in the grid. This is the last known location of the entity.</p>\n\n<ul>\n<li>Note: This is only updated when events realize the route. This means that a route in progress would not have the correct\nlocation until the route is realized (either completed or interrupted by a cancellation or collision).</li>\n</ul>\n"}, {"fullname": "fizgrid.entities.Entity.y_coord", "modulename": "fizgrid.entities", "qualname": "Entity.y_coord", "kind": "variable", "doc": "<p>The y-coordinate of the entity in the grid. This is the last known location of the entity.</p>\n\n<ul>\n<li>Note: This is only updated when events realize the route. This means that a route in progress would not have the correct\nlocation until the route is realized (either completed or interrupted by a cancellation or collision).</li>\n</ul>\n"}, {"fullname": "fizgrid.entities.Entity.history", "modulename": "fizgrid.entities", "qualname": "Entity.history", "kind": "variable", "doc": "<p>The history of the entity's location and collision status. \nThis is a list of dictionaries containing the x, y, t, and c values.</p>\n\n<ul>\n<li>x (int|float): The x-coordinate of the entity in the grid.</li>\n<li>y (int|float): The y-coordinate of the entity in the grid.</li>\n<li>t (int|float): The time at which the entity was at this location.</li>\n<li><p>c (bool): Whether the entity was in a collision at this time.</p></li>\n<li><p>Note: This is only updated when events realize the route. This means that a route in progress would not have history until the\nroute is realized (either completed or interrupted by a cancellation or collision).</p></li>\n</ul>\n"}, {"fullname": "fizgrid.entities.Entity.get_time", "modulename": "fizgrid.entities", "qualname": "Entity.get_time", "kind": "function", "doc": "<p>Returns the current time of the grid queue.\nThis method retrieves the current time from the grid queue.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>int|float: The current time of the grid queue.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.entities.Entity.is_available", "modulename": "fizgrid.entities", "qualname": "Entity.is_available", "kind": "function", "doc": "<p>Returns whether this entity is available for a new route.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>bool: True if the entity is available for a new route, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.entities.Entity.add_route", "modulename": "fizgrid.entities", "qualname": "Entity.add_route", "kind": "function", "doc": "<p>Adds a route to the grid for this entity.</p>\n\n<p>Args:</p>\n\n<ul>\n<li><p>waypoints (list[tuple[int|float,int|float,int|float]]): A list of waypoints to be added to the grid queue.</p>\n\n<ul>\n<li>A list of tuples where each tuple is (x_coord, y_coord, time_shift).</li>\n<li><p>EG:</p>\n\n<pre><code>waypoints = [\n    (5, 3, 10),\n    (3, 5, 10)\n]\n</code></pre>\n\n<ul>\n<li>Move to (5, 3) over 10 seconds</li>\n<li>Move to (3, 5) over 10 seconds</li>\n</ul></li>\n<li>Note: x_coord and y_coord are the coordinates of the waypoint. They must both be positive.</li>\n<li>Note: time_shift is the time it takes to move to the waypoint. It must be positive.</li>\n<li>Optionally, you can use a 4th element to specify the orientation of the shape.\n<ul>\n<li>This orientation is always relative to the original shape</li>\n<li>This is in radians where 0 is facing right (equivalent to the initial shape orientation) and pi is facing left.</li>\n<li>Note: The last used orientation is used until it is changed again (or auto_rotate is set to True).</li>\n</ul></li>\n</ul></li>\n<li>time (int|float|None): The time at which to start the route. If None, the current time is used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.entities.Entity.cancel_route", "modulename": "fizgrid.entities", "qualname": "Entity.cancel_route", "kind": "function", "doc": "<p>Cancels the route for this entity.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>time (int|float|None): The time at which to cancel the route. If None, the current time is used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.entities.Entity.on_realize", "modulename": "fizgrid.entities", "qualname": "Entity.on_realize", "kind": "function", "doc": "<p>Called when the route is realized to allow for custom behavior.\nThis method should be overridden by subclasses to implement custom behavior.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>**kwargs: Additional arguments passed to the method. Subclasses may use this or add their own arguments.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.entities.StaticEntity", "modulename": "fizgrid.entities", "qualname": "StaticEntity", "kind": "class", "doc": "<p>This class is used to represent entities that do not move, such as walls or other static objects.</p>\n\n<p>This is an extension of the Entity class that represents a static entity.</p>\n\n<p>To improve efficiency, many events and logic are avoided as a static entity does not move or respond to events.</p>\n", "bases": "Entity"}, {"fullname": "fizgrid.entities.GhostEntity", "modulename": "fizgrid.entities", "qualname": "GhostEntity", "kind": "class", "doc": "<p>This class is used to represent entities that do not collide with other entities.</p>\n\n<p>It is an extension of the Entity class that represents a ghost entity.</p>\n\n<p>Essentially, these entities can move freely without worrying about collisions. Using them avoids substantial overhead in the simulation and can dramatically improve performance if collisions are irrelevant.</p>\n", "bases": "Entity"}, {"fullname": "fizgrid.grid", "modulename": "fizgrid.grid", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.grid.Grid", "modulename": "fizgrid.grid", "qualname": "Grid", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "fizgrid.grid.Grid.__init__", "modulename": "fizgrid.grid", "qualname": "Grid.__init__", "kind": "function", "doc": "<p>Initializes a grid with the specified parameters.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>name (str): The name of the grid.</li>\n<li>x_size (int): The width of the grid.</li>\n<li>y_size (int): The height of the grid.</li>\n<li>max_time (int): The maximum time for the grid simulation.</li>\n<li>add_exterior_walls (bool): Whether to add exterior walls to the grid.\n<ul>\n<li>Default: True</li>\n</ul></li>\n<li>cell_density (int): The number of cells per unit of length.\n<ul>\n<li>Default: 1</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">x_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">add_exterior_walls</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">cell_density</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span>)</span>"}, {"fullname": "fizgrid.grid.Grid.name", "modulename": "fizgrid.grid", "qualname": "Grid.name", "kind": "variable", "doc": "<p>The name of the grid.</p>\n", "annotation": ": str"}, {"fullname": "fizgrid.grid.Grid.add_entity", "modulename": "fizgrid.grid", "qualname": "Grid.add_entity", "kind": "function", "doc": "<p>Adds an entity to the grid.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>entity (Entity): The entity to be added to the grid.\n<ul>\n<li>Must be an Entity or a subclass of Entity.</li>\n</ul></li>\n<li>time (int|float|None): The time at which the entity should be added to the grid.\n<ul>\n<li>If None, the entity is added immediately.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>Entity: The added entity.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">entity</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">type_enforced</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">WithSubclasses</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.remove_entity", "modulename": "fizgrid.grid", "qualname": "Grid.remove_entity", "kind": "function", "doc": "<p>Removes an entity from the grid.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>entity (Entity): The entity to be removed from the grid.\n<ul>\n<li>Must be an Entity or a subclass of Entity.</li>\n</ul></li>\n<li>time (int|float|None): The time at which the entity should be removed from the grid.\n<ul>\n<li>If None, the entity is removed immediately.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">entity</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">type_enforced</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">WithSubclasses</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.add_event", "modulename": "fizgrid.grid", "qualname": "Grid.add_event", "kind": "function", "doc": "<p>Adds an event to the queue.\nThis method schedules an event for a specific object at a specific time.\nEssentially, it allows you to schedule a method call on an object at a specific time.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>time (int|float): The time at which the event should occur.</li>\n<li>object: The object on which the event will occur.</li>\n<li>method (str): The name of the method to be called on the object.</li>\n<li>kwargs (dict): The keyword arguments to be passed to the method.</li>\n<li>priority (int): The priority of the event.\n<ul>\n<li>Default: 0</li>\n<li>Higher values indicate higher priority.</li>\n<li>This is used to determine the order of events with the same time.</li>\n<li>If two events have the same time, the one with the higher priority will be processed first.</li>\n<li>If the priority is the same, the event with the lower ID will be processed first.</li>\n<li>In general:\n<ul>\n<li>Adding an entity to the grid: 5</li>\n<li>Canceling a route: 4</li>\n<li>Handling collisions: 3</li>\n<li>Resolving an end of route: 2</li>\n<li>Removing an entity from the grid: 1</li>\n<li>Adding a Route: 0</li>\n<li>Adding an event: 0</li>\n</ul></li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>int: The ID of the added event as generated by the queue.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"nb\">object</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">priority</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.get_time", "modulename": "fizgrid.grid", "qualname": "Grid.get_time", "kind": "function", "doc": "<p>Returns the current time of the grid.\nThis method retrieves the current time from the queue.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>int|float: The current time of the grid.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.resolve_next_state", "modulename": "fizgrid.grid", "qualname": "Grid.resolve_next_state", "kind": "function", "doc": "<p>Resolves the next state of the grid.\nThis method processes the next event in the queue and updates the grid accordingly.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>list[dict]: A list of events that were processed in this step.\n<ul>\n<li>Each event is a dictionary containing a time, id and event.</li>\n<li>The event dictionary contains the object, method and kwargs.\n<ul>\n<li>id (int): The ID of the event as generated by the queue.</li>\n<li>time (int|float): The time at which the event occurred.</li>\n<li>event (dict): The event that was processed.\n<ul>\n<li>object: The object on which the event occurred.</li>\n<li>method (str): The name of the method that was called.</li>\n<li>kwargs (dict): The keyword arguments that were passed to the method.</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.add_exterior_walls", "modulename": "fizgrid.grid", "qualname": "Grid.add_exterior_walls", "kind": "function", "doc": "<p>Adds exterior walls to the grid.\nThis method creates walls around the grid to prevent entities from moving outside the grid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.grid.Grid.simulate", "modulename": "fizgrid.grid", "qualname": "Grid.simulate", "kind": "function", "doc": "<p>Runs the simulation for the grid.\nThis method processes events in the queue until all events are resolved or the maximum time is reached.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers", "modulename": "fizgrid.helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.helpers.waypoint_timing", "modulename": "fizgrid.helpers.waypoint_timing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.helpers.waypoint_timing.acceleration", "modulename": "fizgrid.helpers.waypoint_timing.acceleration", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.helpers.waypoint_timing.acceleration.get_max_corner_speeds", "modulename": "fizgrid.helpers.waypoint_timing.acceleration", "qualname": "get_max_corner_speeds", "kind": "function", "doc": "<p>Calculates the maximum speeds that can be taken at each corner in a set of waypoints\ngiven a constant acceleration / deceleration between 0 and max_speed.</p>\n\n<p>The first and last waypoints are always 0 speed.</p>\n\n<p>args:</p>\n\n<ul>\n<li>waypoints: A list of tuples representing the waypoints (x, y).</li>\n<li>max_speed: The maximum speed of the entity.</li>\n<li>acceleration: The acceleration/deceleration of the entity.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">max_speed</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.acceleration.acceleration_waypoint_time_approximation", "modulename": "fizgrid.helpers.waypoint_timing.acceleration", "qualname": "acceleration_waypoint_time_approximation", "kind": "function", "doc": "<p>Partitions a set of waypoints (list of tuples(x,y)) into a list of (x,y,time_delta) tuples\ngiven a constant acceleration / deceleration between 0 and max_speed.</p>\n\n<p>Each waypoint can be partitioned into an acceleration, cruise and deceleration phase (as applicable).</p>\n\n<p>args:</p>\n\n<ul>\n<li>start_x: The x coordinate of the starting point.</li>\n<li>start_y: The y coordinate of the starting point.</li>\n<li>waypoints: A list of tuples representing the waypoints (x, y).</li>\n<li>max_speed: The maximum speed of the entity.</li>\n<li>acceleration: The acceleration/deceleration of the entity.</li>\n<li>round_time_to: The number of decimal places to round the time to. Default is 4.</li>\n</ul>\n\n<p>Returns</p>\n\n<ul>\n<li>list of tuples:  representing the waypoints (x, y, time_delta).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start_x</span>,</span><span class=\"param\">\t<span class=\"n\">start_y</span>,</span><span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">max_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">round_time_to</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.simple", "modulename": "fizgrid.helpers.waypoint_timing.simple", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.helpers.waypoint_timing.simple.simple_waypoint_time_approximation", "modulename": "fizgrid.helpers.waypoint_timing.simple", "qualname": "simple_waypoint_time_approximation", "kind": "function", "doc": "<p>A helper function to approximate waypoint times assuming a constant entity speed\nReturns the waypoints with the time it would take to travel between them given the constant speed.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>start_x: The x coordinate of the starting point.</li>\n<li>start_y: The y coordinate of the starting point.</li>\n<li>waypoints: A list of tuples representing the waypoints to be traversed by the moving entity.</li>\n<li>speed: The constant speed of the moving entity.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A list of tuples representing the waypoints with the time it would take to travel between them given the constant speed.\n<ul>\n<li>Each tuple contains the x and y coordinates of the original waypoint as well as the time delta to travel to said waypoint.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">start_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils", "modulename": "fizgrid.helpers.waypoint_timing.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils.get_distance", "modulename": "fizgrid.helpers.waypoint_timing.utils", "qualname": "get_distance", "kind": "function", "doc": "<p>Returns the Euclidean distance between two points.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>pt1: The first point (x, y).</li>\n<li>pt2: The second point (x, y).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The distance between the two points.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pt1</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">pt2</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils.get_angle", "modulename": "fizgrid.helpers.waypoint_timing.utils", "qualname": "get_angle", "kind": "function", "doc": "<p>Calculates the angle when going from pt1 to pt2 to pt3.</p>\n\n<p>Returns the angle in degrees.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>pt1: The first point (x, y).</li>\n<li>pt2: The second point (x, y).</li>\n<li>pt3: The third point (x, y).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The angle in degrees.</li>\n</ul>\n\n<p>Examples:</p>\n\n<p>EG: (0, 0) -> (1, 0) -> (2, 0) =&gt; 180\nEG: (0, 0) -> (1, 0) -> (1, 1) =&gt; 90</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pt1</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">pt2</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">pt3</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils.get_acceleration_distance", "modulename": "fizgrid.helpers.waypoint_timing.utils", "qualname": "get_acceleration_distance", "kind": "function", "doc": "<p>Calculates the distance required to accelerate/decelerate from start_speed to end_speed\ngiven a constant acceleration.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>start_speed: The speed at which the object is currently traveling.</li>\n<li>end_speed: The speed at which the object will be traveling.</li>\n<li>acceleration: The acceleration of the object (should always be positive as start and end speeds determine if it is accelerating or decelerating).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The distance required to accelerate/decelerate from start_speed to end_speed.\n<ul>\n<li>If start_speed and end_speed are equal, 0 is returned.</li>\n<li>If start_speed is greater than end_speed, the function will return the distance required to decelerate from start_speed to end_speed.</li>\n<li>If start_speed is less than end_speed, the function will return the distance required to accelerate from start_speed to end_speed.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">end_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils.get_end_speed", "modulename": "fizgrid.helpers.waypoint_timing.utils", "qualname": "get_end_speed", "kind": "function", "doc": "<p>Calculates the speed at wich an object will be traveling after a given distance\ngiven a constant acceleration.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>start_speed: The speed at which the object is currently traveling.</li>\n<li>distance: The distance over which the object will be traveling.</li>\n<li>acceleration: The acceleration/deceleration of the object (positive for acceleration, negative for deceleration).</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>float: The speed at which the object will be traveling after the given distance.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.helpers.waypoint_timing.utils.partition_distance", "modulename": "fizgrid.helpers.waypoint_timing.utils", "qualname": "partition_distance", "kind": "function", "doc": "<p>Partitions a distance into time and distance for acceleration, cruise and deceleration</p>\n\n<p>args:</p>\n\n<ul>\n<li>distance: The distance to be traveled.</li>\n<li>start_speed: The speed at which the entity is currently traveling.</li>\n<li>max_end_speed: The maximum ending speed that the entity can travel at.</li>\n<li>max_speed: The maximum speed of the entity.</li>\n<li>acceleration: The acceleration/deceleration of the entity.</li>\n</ul>\n\n<p>Returns a tuple</p>\n\n<ul>\n<li>0: list of dictionaries with the following keys:\n<ul>\n<li>end_pct: The percentage of the distance at which the partition ends.</li>\n<li>time: The time it takes to travel the distance in the partition.</li>\n</ul></li>\n<li>1: int or float: The ending speed</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">distance</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">start_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">max_end_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">max_speed</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">acceleration</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.queue", "modulename": "fizgrid.queue", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.queue.TimeQueue", "modulename": "fizgrid.queue", "qualname": "TimeQueue", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "fizgrid.queue.TimeQueue.__init__", "modulename": "fizgrid.queue", "qualname": "TimeQueue.__init__", "kind": "function", "doc": "<p>Initializes a TimeQueue instance.\nThis class is used to manage a queue of events that occur at specific times.\nIt uses a min-heap to efficiently manage the events based on their scheduled times.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "fizgrid.queue.TimeQueue.add_event", "modulename": "fizgrid.queue", "qualname": "TimeQueue.add_event", "kind": "function", "doc": "<p>Adds an event to the queue.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>time (int|float): The time at which the event should occur.</li>\n<li>event (dict): The event to be added to the queue.\n<ul>\n<li>Default: {}</li>\n<li>This have any dictionary strucutre, depending on your queue needs</li>\n</ul></li>\n<li>priority (int): The priority of the event.\n<ul>\n<li>Default: 0</li>\n<li>Higher values indicate higher priority.</li>\n<li>This is used to determine the order of events with the same time.</li>\n<li>If two events have the same time, the one with the higher priority will be processed first.</li>\n<li>If the priority is the same, the event with the lower ID will be processed first.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>int: The ID of the added event.\n<ul>\n<li>This ID is used to reference the event in the queue.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">priority</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.queue.TimeQueue.remove_event", "modulename": "fizgrid.queue", "qualname": "TimeQueue.remove_event", "kind": "function", "doc": "<p>Removes an event from the queue using its ID.</p>\n\n<p>Args:</p>\n\n<pre><code>- id (int): The ID of the event to be removed.\n    - This ID is used to reference the event in the queue.\n</code></pre>\n\n<p>Returns:\n    - dict: The removed event.\n        - If the event is not found, None is returned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.queue.TimeQueue.remove_next_event", "modulename": "fizgrid.queue", "qualname": "TimeQueue.remove_next_event", "kind": "function", "doc": "<p>Removes the next event from the queue.\nThis method is used to get the next event in the queue and remove it from the heap.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict: The removed event.\n<ul>\n<li>If the queue is empty, None is returned.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.queue.TimeQueue.get_next_event", "modulename": "fizgrid.queue", "qualname": "TimeQueue.get_next_event", "kind": "function", "doc": "<p>Retrieves the next event from the queue without removing it.\nThis method is used to get the next event in the queue</p>\n\n<p>Args:</p>\n\n<ul>\n<li>peek (bool): If True, the event is not removed from the queue.\n<ul>\n<li>Default: False</li>\n<li>If False, the event is removed from the queue.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict: The next event in the queue.\n<ul>\n<li>If the queue is empty, None is returned.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">peek</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.queue.TimeQueue.get_next_events", "modulename": "fizgrid.queue", "qualname": "TimeQueue.get_next_events", "kind": "function", "doc": "<p>Retrieves all events that occur at the same time as the next event.\nThis method is used to get all events that occur at the same time as the next event in the queue.\nIt removes these events from the queue.</p>\n\n<p>Returns:</p>\n\n<ul>\n<li>list: A list of events that occur at the same time as the next event.\n<ul>\n<li>If the queue is empty, an empty list is returned.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils", "modulename": "fizgrid.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fizgrid.utils.unique_id", "modulename": "fizgrid.utils", "qualname": "unique_id", "kind": "function", "doc": "<p>Generates a unique identifier.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.Shape", "modulename": "fizgrid.utils", "qualname": "Shape", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "fizgrid.utils.Shape.circle", "modulename": "fizgrid.utils", "qualname": "Shape.circle", "kind": "function", "doc": "<p>Returns a list of addative coordinates that form a circle around a given point.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>radius (int|float): Radius of the circle.</li>\n<li>num_points (int): Number of points to generate around the circle.\n<ul>\n<li>Default: 6</li>\n<li>This is used to determine the number of points to generate around the circle.</li>\n</ul></li>\n<li>round_to (int): Number of decimal places to round to.\n<ul>\n<li>Default: 2</li>\n<li>This is used to round the coordinates to a specific number of decimal places.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list[list]: A list of coordinates representing the circle.\n<ul>\n<li>Each coordinate is a list of two values [x, y].</li>\n<li>The coordinates are relative to the center of the circle.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">num_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">6</span>,</span><span class=\"param\">\t<span class=\"n\">round_to</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.Shape.rectangle", "modulename": "fizgrid.utils", "qualname": "Shape.rectangle", "kind": "function", "doc": "<p>Returns a list of addative coordinates that form a rectangle around a given point.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>x_len (float|int): Length of the rectangle along the x-axis.</li>\n<li>y_len (float|int): Length of the rectangle along the y-axis.</li>\n<li>round_to (int): Number of decimal places to round to.\n<ul>\n<li>Default: 2</li>\n<li>This is used to round the coordinates to a specific number of decimal places.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list[list]: A list of coordinates representing the rectangle.\n<ul>\n<li>Each coordinate is a list of two values [x, y].</li>\n<li>The coordinates are relative to the center of the rectangle.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_len</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y_len</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">round_to</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.Shape.rotate", "modulename": "fizgrid.utils", "qualname": "Shape.rotate", "kind": "function", "doc": "<p>Rotates a shape by a given angle in radians around its origin (0, 0).\nArgs:</p>\n\n<ul>\n<li>radians (float|int): The angle in radians to rotate the shape.</li>\n<li>shape (list[list[float|int]]): The shape to rotate.\n<ul>\n<li>This is a list of coordinates representing the shape.</li>\n<li>Each coordinate is a list of two values [x, y].\nReturns:</li>\n</ul></li>\n<li>list[list[float|int]]: The rotated shape.\n<ul>\n<li>This is a list of coordinates representing the rotated shape.</li>\n<li>Each coordinate is a list of two values [x, y].</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">radians</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">round_to</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.Shape.get_rotated_shape", "modulename": "fizgrid.utils", "qualname": "Shape.get_rotated_shape", "kind": "function", "doc": "<p>Rotates the shape to align with the direction of motion.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>shape (list[list[float|int]]): List of coordinates representing the shape's vertices relative to its center.</li>\n<li>x_shift (float|int): Total distance the shape moves along the x-axis during [t_start, t_end].</li>\n<li>y_shift (float|int): Total distance the shape moves along the y-axis during [t_start, t_end].</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>list[list[float|int]]: The rotated shape.\n<ul>\n<li>This is a list of coordinates representing the rotated shape.</li>\n<li>Each coordinate is a list of two values [x, y].</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">x_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.moving_segment_overlap_intervals", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.moving_segment_overlap_intervals", "kind": "function", "doc": "<p>Calculates the time intervals during which a moving 1D line segment overlaps with each unit-length\ninteger-aligned range along the x-axis.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>seg_start (int|float): Initial position of the left end of the line segment.</li>\n<li>seg_end (int|float): Initial position of the right end of the line segment.</li>\n<li>t_start (int|float): Start time of the motion.</li>\n<li>t_end (int|float): End time of the motion.</li>\n<li>shift (int|float): Total distance the line segment moves along the x-axis during [t_start, t_end].</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict[int, tuplie(int|float,int|float)]: A dictionary mapping each integer <code>i</code> to the time interval [t_in, t_out]\nduring which any part of the line overlaps the range [i, i+1).\nOnly includes ranges with non-zero overlap duration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">seg_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">seg_end</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">t_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">t_end</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">shift</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.moving_rectangle_overlap_intervals", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.moving_rectangle_overlap_intervals", "kind": "function", "doc": "<p>Calculates the time intervals during which a moving rectangle overlaps with each unit-length\ninteger-aligned range along the x and y axes.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>x_start (float|int): Initial position of the left end of the rectangle along the x-axis.</li>\n<li>x_end (float|int): Initial position of the right end of the rectangle along the x-axis.</li>\n<li>y_start (float|int): Initial position of the bottom end of the rectangle along the y-axis.</li>\n<li>y_end (float|int): Initial position of the top end of the rectangle along the y-axis.</li>\n<li>x_shift (float|int): Total distance the rectangle moves along the x-axis during [t_start, t_end].</li>\n<li>y_shift (float|int): Total distance the rectangle moves along the y-axis during [t_start, t_end].</li>\n<li>t_start (float|int): Start time of the motion.</li>\n<li>t_end (float|int): End time of the motion.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict[tuple(int,int),tuple(int|float,int|float)]: A dictionary mapping each integer (i,j) to the time interval [t_in, t_out]\nduring which any part of the rectangle overlaps the range [i, i+1) x [j, j+1).\nOnly includes ranges with non-zero overlap duration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x_start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">x_end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">x_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t_start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t_end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.argmin", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.argmin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lst</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.argmax", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.argmax", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lst</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.find_extreme_orthogonal_vertices", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.find_extreme_orthogonal_vertices", "kind": "function", "doc": "<p>Finds the points in a list that are the furthest apart in the direction\northogonal to the given slope. This is useful for finding the extreme\npoints in a set of 2D coordinates that are orthogonal to a given line.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>points (list of tuples): A list of (x, y) coordinates.</li>\n<li>slope (float): The slope of the line.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>tuple: The points with the minimum and maximum projections.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">slope</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.find_extreme_orthogonal_vertices_simplified", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.find_extreme_orthogonal_vertices_simplified", "kind": "function", "doc": "<p>A simplified version of the function <code>find_extreme_orthogonal_vertices</code>\nthat assumes the slope is never 0.</p>\n\n<p>Finds the points in a list that are the furthest apart in the direction\northogonal to the given slope. This is useful for finding the extreme\npoints in a set of 2D coordinates that are orthogonal to a given line.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>points (list of tuples): A list of (x, y) coordinates.</li>\n<li>slope (float): The slope of the line.\n<ul>\n<li>Note: This should never be 0 or infinite for this function.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>tuple: The points with the minimum and maximum projections.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">slope</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.remove_untouched_intervals", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.remove_untouched_intervals", "kind": "function", "doc": "<p>Removes unnecessary intervals from the dictionary of intervals.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>intervals (dict[tuple(int,int),tuple(int|float,int|float)]): A dictionary mapping each integer (i,j) to the time interval [t_in, t_out]\nduring which any part of the shape overlaps the range [i, i+1) x [j, j+1).</li>\n<li>slope (float|int): The slope of the line.</li>\n<li>absolute_shape (list(tuple[int|float, int|float])): A list of coordinates representing the shape's vertices relative to its center.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict[tuple(int,int),tuple(int|float,int|float)]: A dictionary with unnecessary intervals removed.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">intervals</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">slope</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">absolute_shape</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fizgrid.utils.ShapeMoverUtils.moving_shape_overlap_intervals", "modulename": "fizgrid.utils", "qualname": "ShapeMoverUtils.moving_shape_overlap_intervals", "kind": "function", "doc": "<p>Calculates the time intervals during which a moving shape overlaps with each unit-length\ninteger-aligned range along the x and y axes.</p>\n\n<p>Note: This converts each shape into a full bounding box rectangle and then uses the rectangle overlap function to calculate the intervals.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>x_coord (float|int): Initial x-coordinate of the shape's center.</li>\n<li>y_coord (float|int): Initial y-coordinate of the shape's center.</li>\n<li>x_shift (float|int): Total distance the shape moves along the x-axis during [t_start, t_end].</li>\n<li>y_shift (float|int): Total distance the shape moves along the y-axis during [t_start, t_end].</li>\n<li>t_start (float|int): Start time of the motion.</li>\n<li>t_end (float|int): End time of the motion.</li>\n<li>shape (list[list[float|int]]): List of coordinates representing the shape's vertices relative to its center.</li>\n<li>cell_density (int): The number of cells per unit of length.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict[tuple(int,int),tuple(int|float,int|float)]: A dictionary mapping each integer (i,j) to the time interval [t_in, t_out]\nduring which any part of the shape overlaps the range [i, i+1) x [j, j+1).\nOnly includes ranges with non-zero overlap duration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x_coord</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_coord</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">x_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y_shift</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t_start</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t_end</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">cell_density</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();